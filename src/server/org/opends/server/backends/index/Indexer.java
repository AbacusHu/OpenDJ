/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at
 * trunk/opends/resource/legal-notices/OpenDS.LICENSE
 * or https://OpenDS.dev.java.net/OpenDS.LICENSE.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at
 * trunk/opends/resource/legal-notices/OpenDS.LICENSE.  If applicable,
 * add the following below this CDDL HEADER, with the fields enclosed
 * by brackets "[]" replaced with your own identifying information:
 *      Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 *
 *      Copyright 2006-2009 Sun Microsystems, Inc.
 */
package org.opends.server.backends.index;


import java.util.Comparator;
import java.util.Set;
import java.util.List;
import java.util.Map;
import org.opends.server.types.AttributeType;
import org.opends.server.types.Entry;
import org.opends.server.types.Modification;
import org.opends.server.types.Attribute;
import com.sleepycat.je.DatabaseException;
import org.opends.server.types.ByteString;

/**
 * This class attempts to abstract the generation and comparison of keys
 * for an index.
 */
public class Indexer
{
  /**
   * The attribute type for which this instance will
   * generate index keys.
   */
  private AttributeType attributeType;



  /**
   * The Index key factory for generating the keys.
   */
  private IndexKeyFactory keyFactory;



  /**
   * Create a new attribute indexer for the given index configuration.
   *
   * @param attributeType The attribute type for which an indexer is
   *                                       required.
   * @param keyFactory The index key factory which generates the
   *                                    index keys.
   */
  public Indexer(AttributeType attributeType, IndexKeyFactory keyFactory)
  {
    this.attributeType = attributeType;
    this.keyFactory = keyFactory;
  }



  /**
   * Get the comparator that must be used to compare index keys
   * generated by this class.
   *
   * @return A byte array comparator.
   */
  public Comparator<byte[]> getComparator()
  {
    return keyFactory.getComparator();
  }



  /**
   * Generate the set of index keys for an entry.
   *
   * @param entry The entry.
   * @param keys The set into which the generated keys will be inserted.
   * @throws DatabaseException If an error occurs in the backend database.
   */
  public void indexEntry(Entry entry, Set<byte[]> keys)
       throws DatabaseException
  {
    List<Attribute> attrList = entry.getAttribute(attributeType);
    KeySet keySet = new AddKeySet(keys);
    indexAttribute(attrList,keySet);
  }



  /**
   * Generate the set of index keys to be added and the set of index keys
   * to be deleted for an entry that has been replaced.
   *
   * @param oldEntry The original entry contents.
   * @param newEntry The new entry contents.
   * @param modifiedKeys The map into which the modified keys will be inserted.
   * @throws DatabaseException If an error occurs in the backend database.
   */
  public void replaceEntry(Entry oldEntry, Entry newEntry,
                                    Map<byte[], Boolean> modifiedKeys)
       throws DatabaseException
  {
    List<Attribute> newAttributes = newEntry.getAttribute(attributeType, true);
    List<Attribute> oldAttributes = oldEntry.getAttribute(attributeType, true);

    ModifyKeySet oldKeySet = new ModifyKeySet(modifiedKeys,false);
    indexAttribute(oldAttributes, oldKeySet);
    ModifyKeySet newKeySet = new ModifyKeySet(oldKeySet.getMap(),true);
    indexAttribute(newAttributes, newKeySet);
  }



  /**
   * Generate the set of index keys to be added and the set of index keys
   * to be deleted for an entry that was modified.
   *
   * @param oldEntry The original entry contents.
   * @param newEntry The new entry contents.
   * @param mods The set of modifications that were applied to the entry.
   * @param modifiedKeys The map into which the modified keys will be inserted.
   * @throws DatabaseException If an error occurs in the backend database.
   */
  public  void modifyEntry(Entry oldEntry, Entry newEntry,
                                   List<Modification> mods,
                                   Map<byte[], Boolean> modifiedKeys)
       throws DatabaseException
  {
    List<Attribute> newAttributes = newEntry.getAttribute(attributeType, true);
    List<Attribute> oldAttributes = oldEntry.getAttribute(attributeType, true);

    ModifyKeySet oldKeySet = new ModifyKeySet(modifiedKeys,false);
    indexAttribute(oldAttributes, oldKeySet);
    ModifyKeySet newKeySet = new ModifyKeySet(oldKeySet.getMap(),true);
    indexAttribute(newAttributes, newKeySet);
  }



  /**
   * Generates the set of extensible  index keys for an attribute.
   * @param attrList The attribute for which substring keys are required.
   * @param keys The set into which the generated keys will be inserted.
   */
  private void indexAttribute(List<Attribute> attrList,
                              KeySet keySet)
  {
    if (attrList == null)
    {
      return;
    }
    keyFactory.getKeys(attrList,keySet);
  }



  /**
   * Get a string representation of this object.  The returned value is
   * used to name an index created using this object.
   * @return A string representation of this object.
   */
  @Override()
  public String toString()
  {
    return attributeType.getNameOrOID() + "." +
            keyFactory.getIndexID();
  }



  /**
   * This class provides an implementation for KeySet interface. It is
   * used in the cases where the new index keys need to be added.
   */
  public static class AddKeySet implements KeySet
  {
    //Data structure for storing keys.
    private Set<byte[]> keySet;


    /**
     * Creates a new instance.
     * @param keySet The set of index keys.
     */
    public AddKeySet(Set<byte[]> keySet)
    {
      this.keySet = keySet;
    }


    /**
     * {@inheritDoc}
     */
    public void addKey(byte[] b)
    {
      keySet.add(b);
    }



    /**
     * {@inheritDoc}
     */
    public void addKey(ByteString s)
    {
      keySet.add(s.toByteArray());
    }



    /**
     * {@inheritDoc}
     */
    public Set<byte[]> getKeys()
    {
      return keySet;
    }
  }



  /**
   * This class provides an implementation for KeySet interface. It is
   * used in the cases where the new index keys need to be modified.
   *
   */
  public static class ModifyKeySet implements KeySet
  {
    //Data structure for storing keys.
    private Map<byte[], Boolean> modifiedKeyMap;



    //Whether the key needs to be inserted.
    private boolean isInsert;



    /**
     * Creates a new instance.
     * @param modifiedKeyMap The map containing the keys and a boolean
     *          indicating whether they need to be inserted or deleted.
     * @param isInsert Whether the key need to be inserted or deleted.
     */
    public ModifyKeySet(Map<byte[], Boolean> modifiedKeyMap,boolean isInsert)
    {
      this.modifiedKeyMap = modifiedKeyMap;
      this.isInsert = isInsert;
    }


    /**
     * {@inheritDoc}
     */
    public void addKey(byte[] b)
    {
      Boolean cInsert = modifiedKeyMap.get(b);
      if(cInsert == null)
      {
        modifiedKeyMap.put(b,isInsert);
      }
      else if(!cInsert.equals(isInsert))
      {
        modifiedKeyMap.remove(b);
      }
    }



    /**
     * {@inheritDoc}
     */
    public void addKey(ByteString s)
    {
      addKey(s.toByteArray());
    }



    /**
     * {@inheritDoc}
     */
    public Set<byte[]> getKeys()
    {
      return modifiedKeyMap.keySet();
    }



    /**
     * Returns the map of the key and the boolean flag which indicates
     * whether the key needs to be inserted or deleted.
     * @return A map of keys and corresponding boolean flag.
     */
    public Map<byte[],Boolean> getMap()
    {
      return modifiedKeyMap;
    }
  }
}
